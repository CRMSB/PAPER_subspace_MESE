var documenterSearchIndex = {"docs":
[{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"EditURL = \"../../../lit/examples/subspace_julia_epg.jl\"","category":"page"},{"location":"generated/examples/subspace_julia_epg/#03-subspaceReconstruction","page":"Generate article figure","title":"Generate article figure","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/#Description","page":"Generate article figure","title":"Description","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"This example described how to perform a subspace reconstruction for T_2 mapping acceleration. This script is also used to generate the last figure of the article.","category":"page"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"(Image: Reconstruction Pipeline)","category":"page"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"To do so you need to edit path_raw to the bruker dataset available here and you need to compile bart and edit path_bart to the compiled bart library","category":"page"},{"location":"generated/examples/subspace_julia_epg/#Setup-and-define-global-variable","page":"Generate article figure","title":"Setup and define global variable","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"using Subspace_MESE\nusing Subspace_MESE.MRIFiles\nusing Subspace_MESE.MRIReco\nusing Subspace_MESE.MRICoilSensitivities\nusing Subspace_MESE.LinearAlgebra\nusing Subspace_MESE.FFTW\nusing CairoMakie","category":"page"},{"location":"generated/examples/subspace_julia_epg/#Define-the-path-to-the-raw-dataset","page":"Generate article figure","title":"Define the path to the raw dataset","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"If the folder/file does not exists we are in the github CI environement and we used for the plots the images","category":"page"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"path_raw = \"/workspace_QMRI/PROJECTS_DATA/2021_RECH_mcT2_Bruker/PROJ_JULIA_MSME_CS/data/exp_raw/mouse_patho/20230317_085834_AT_MSME_CS_44_1_1/10\"","category":"page"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"define the path to the bart library","category":"page"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"path_bart = \"/home/CODE/bart/bart\"\n\nslice_to_show = 55","category":"page"},{"location":"generated/examples/subspace_julia_epg/#Load-and-convert-the-bruker-dataset-into-an-AcquisitionData-object","page":"Generate article figure","title":"Load and convert the bruker dataset into an AcquisitionData object","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"b = BrukerFile(path_raw)\n\nraw = RawAcquisitionData_MESE(b)\nacq = AcquisitionData(raw,OffsetBruker = true);\nnothing #hide","category":"page"},{"location":"generated/examples/subspace_julia_epg/#Estimate-the-coil-sensitivity-map-with-espirit","page":"Generate article figure","title":"Estimate the coil sensitivity map with espirit","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"coilsens = espirit(acq,eigThresh_2=0.0);\nnothing #hide","category":"page"},{"location":"generated/examples/subspace_julia_epg/#Undersampling-Recontruction","page":"Generate article figure","title":"Undersampling Recontruction","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"params = Dict{Symbol,Any}()\nparams[:reconSize] = acq.encodingSize\nparams[:reco] = \"direct\"\n\nim_u = reconstruction(acq, params);\nim_u_sos = mergeChannels(im_u)\n\nheatmap(im_u_sos[:,:,55,15,1,1],colormap=:grays)","category":"page"},{"location":"generated/examples/subspace_julia_epg/#Generate-basis-from-an-EPG-simulation","page":"Generate article figure","title":"Generate basis from an EPG simulation","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"B1_vec = 0.8:0.01:1.0\nT2_vec = 1.0:1.0:2000.0\nT1_vec = 1000.0\nTE = 7.0\nTR = 1000.0\ndummy=3\nETL = 50\nNUM_BASIS = 6\nbasis_epg,_= MESE_basis_EPG(NUM_BASIS,TE,ETL,T2_vec,B1_vec,T1_vec;TR=TR,dummy=dummy)\nlines(abs.(basis_epg[:,2]))","category":"page"},{"location":"generated/examples/subspace_julia_epg/#Subspace-reconstruction-with-EPG-dictionnary","page":"Generate article figure","title":"Subspace reconstruction with EPG dictionnary","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"params = Dict{Symbol,Any}()\nparams[:reconSize] = acq.encodingSize\nparams[:reco] = \"multiCoilMultiEchoSubspace\"\n\nparams[:regularization] = \"L1\"\nparams[:sparseTrafo] = \"Wavelet\" #sparse trafo\nparams[:λ] = Float32(0.03)\nparams[:solver] = \"fista\"\nparams[:iterations] = 60\n#params[:iterationsInner] = 5\nparams[:senseMaps] = coilsens\nparams[:normalizeReg] = true\nparams[:basis] = basis_epg\n\nα_epg = reconstruction(acq, params)\nim_TE_julia = abs.(applySubspace(α_epg, params[:basis]));\nnothing #hide","category":"page"},{"location":"generated/examples/subspace_julia_epg/#BART-reco","page":"Generate article figure","title":"BART reco","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"In order to use BartIO, we need to send the path to the bart library. You can check that it works with the following code","category":"page"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"BartIO.set_bart_path(\"path_bart\")\nbart()","category":"page"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"if isfile(path_bart)\n    using Subspace_MESE.BartIO\n\n    params[:λ] = Float32(0.0025)\n    im_sub_bart,im_TE_bart = subspace_bart_reconstruction(acq,params,path_bart)\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/subspace_julia_epg/#Fit-the-data-to-obtain-T-maps","page":"Generate article figure","title":"Fit the data to obtain T₂ maps","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"TE_vec = Float32.(LinRange(TE,TE*ETL,ETL))\n\nsl = Tuple[]\npush!(sl,(:,:,slice_to_show))\npush!(sl,(:,65,:))\npush!(sl,(65,:,:))\n\nfit_und = Any[]\nfit_julia = Any[]\nfit_bart = Any[]\nfor i in eachindex(sl)\n    push!(fit_und,Subspace_MESE.T2Fit_exp_noise(abs.(im_u_sos[sl[i]...,:,1,1]),TE_vec;removePoint=true,L=4))\n    push!(fit_julia,Subspace_MESE.T2Fit_exp_noise(abs.(im_TE_julia[sl[i]...,:,1,1]),TE_vec;removePoint=true,L=4))\n    if isfile(path_bart)\n        push!(fit_bart,Subspace_MESE.T2Fit_exp_noise(abs.(im_TE_bart[sl[i]...,1,1,:]),TE_vec;removePoint=true,L=4))\n    end;\nend","category":"page"},{"location":"generated/examples/subspace_julia_epg/#Generating-article-figure-8","page":"Generate article figure","title":"Generating article figure 8","text":"","category":"section"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"using CairoMakie.Makie.MakieCore\nbegin\ntitlesize=20\nylabelsize=20\naspect = DataAspect()\n\nf=Figure(size=(1200,1600))\n#plot echo 1\ncolorrange=MakieCore.Automatic()\ncolormap=:grays\n\nax = Axis(f[1,1];title=\"FFT\\n \",ylabel = \"Echo n°1\\nTE = 7 ms\",titlesize,ylabelsize)\nheatmap!(ax,circshift(im_u_sos[:,:,slice_to_show,1,1,1],(0,-10));colorrange,colormap)\nhidedecorations!(ax,label=false)\nax = Axis(f[1,2];title=\"MRIReco\\nW=0.03\",titlesize)\nheatmap!(ax,circshift(im_TE_julia[:,:,slice_to_show,1,1,1],(0,-10));colorrange,colormap)\nhidedecorations!(ax)\n\nif(isfile(path_bart))\n    ax = Axis(f[1,3];title=\"BART\\nW=0.0025\",titlesize)\n    heatmap!(ax,circshift(abs.(im_TE_bart[:,:,slice_to_show,1,1,1]),(0,-10));colorrange,colormap)\n    hidedecorations!(ax)\nend\n\n#plot echo 10\n\nax = Axis(f[2,1];ylabel = \"Echo n°10\\nTE = 70 ms\",titlesize,ylabelsize)\nheatmap!(ax,circshift(im_u_sos[:,:,slice_to_show,10,1,1],(0,-10));colorrange,colormap)\nhidedecorations!(ax,label=false)\nax = Axis(f[2,2];titlesize)\nheatmap!(ax,circshift(im_TE_julia[:,:,slice_to_show,10,1,1],(0,-10));colorrange,colormap)\nhidedecorations!(ax)\n\nif(isfile(path_bart))\n    ax = Axis(f[2,3];titlesize)\n    heatmap!(ax,circshift(abs.(im_TE_bart[:,:,slice_to_show,1,1,10]),(0,-10));colorrange,colormap)\n    hidedecorations!(ax)\nend\n\n#plot T2 map\ncolorrange=(0,150)\ncolormap=:magma\n\nax = Axis(f[3,1];ylabel = \"T₂ map: coronal\",titlesize,ylabelsize)\nheatmap!(ax,circshift(fit_und[1][:,:,2],(0,-10));colorrange,colormap)\nhidedecorations!(ax,label=false)\nax = Axis(f[3,2])\nh=heatmap!(ax,circshift(fit_julia[1][:,:,2],(0,-10));colorrange,colormap)\nhidedecorations!(ax)\nif(isfile(path_bart))\n    ax = Axis(f[3,3])\n    heatmap!(ax,circshift(fit_bart[1][:,:,2],(0,-10));colorrange,colormap)\n    hidedecorations!(ax)\nend\nColorbar(f[3,4],h,label = \"T₂ [ms]\",labelrotation=-pi/2,labelsize=20)\n#rowgap!(f.layout,3,10)\n\n#plot T2 sag\nsl_c = (0,20)\nax = Axis(f[4,1];ylabel = \"T₂ map: sagittal\",titlesize,ylabelsize,aspect=128/96)\nheatmap!(ax,circshift(reverse(fit_und[2][:,:,2],dims=2),sl_c);colorrange,colormap)\nhidedecorations!(ax,label=false)\nax = Axis(f[4,2],aspect=128/96)\nh=heatmap!(ax,circshift(reverse(fit_julia[2][:,:,2],dims=2),sl_c);colorrange,colormap)\nhidedecorations!(ax)\nif(isfile(path_bart))\n    ax = Axis(f[4,3],aspect=128/96)\n    heatmap!(ax,circshift(reverse(fit_bart[2][:,:,2],dims=2),sl_c);colorrange,colormap)\n    hidedecorations!(ax)\nend\nColorbar(f[4,4],h,label = \"T₂ [ms]\",labelrotation=-pi/2,labelsize=20,height=Relative(0.85))\nrowgap!(f.layout,3,-10)\n\n#plot T2 axial\nsl_c = (-10,20)\nax = Axis(f[5,1];ylabel = \"T₂ map : axial\",titlesize,ylabelsize,aspect=128/96)\nheatmap!(ax,circshift(reverse(fit_und[3][:,:,2],dims=2),sl_c);colorrange,colormap)\nhidedecorations!(ax,label=false)\nax = Axis(f[5,2],aspect=128/96)\nh=heatmap!(ax,circshift(reverse(fit_julia[3][:,:,2],dims=2),sl_c);colorrange,colormap)\nhidedecorations!(ax)\nif(isfile(path_bart))\n    ax = Axis(f[5,3],aspect=128/96)\n    heatmap!(ax,circshift(reverse(fit_bart[3][:,:,2],dims=2),sl_c);colorrange,colormap)\n    hidedecorations!(ax)\nend\nColorbar(f[5,4],h,label = \"T₂ [ms]\",labelrotation=-pi/2,labelsize=20,height=Relative(0.85))\nrowgap!(f.layout,4,-35)\n\nf\nend\n\nsave(\"fig_bart_julia.png\",f)\nsave(\"fig_bart_julia.eps\",f)\nsave(\"fig_bart_julia.pdf\",f)","category":"page"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"","category":"page"},{"location":"generated/examples/subspace_julia_epg/","page":"Generate article figure","title":"Generate article figure","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fit_T2/#Fitting-the-data","page":"T₂ mapping","title":"Fitting the data","text":"","category":"section"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"The reconstruction and the fitting parts are totally independent.","category":"page"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"The fitting functions expects a multidimensionnal-array with the echoes along the last dimension. The images should not be in complex, remember to use abs.(img)","category":"page"},{"location":"fit_T2/#Exponential-T_2-fitting-noise","page":"T₂ mapping","title":"Exponential T_2 fitting + noise","text":"","category":"section"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"In the publication we used an analytical model to fit the exponential decay of the echoes :","category":"page"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"S(t) = sqrtleft(M_0  exp(-fractT_2)right)^2 + 2  L  sigma_g^2","category":"page"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"where L is the number of coil and sigma_g corresponds to the gaussian noise level on image","category":"page"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"You can perform this fit with the following function :","category":"page"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"T2Fit_exp_noise","category":"page"},{"location":"fit_T2/#Subspace_MESE.T2Fit_exp_noise","page":"T₂ mapping","title":"Subspace_MESE.T2Fit_exp_noise","text":"    T2Fit_exp_noise(ima::Array{T,N}, t::AbstractVector{T}; removePoint::Bool=true, L::Int=1, mask = nothing) where {T<:Real,N}\n\nFit the relaxation parameters T2 with the equation : S(t) = sqrt(M_0 exp(-fractT2))^2 + 2 L sigma_g^2 where L est le nombre de canaux, et sigma_g le bruit gaussien sur les image\n\nArguments\n\nima::Array{T,N}: multi-dimensionnal images. Last dimension stores the temporal dimension\nt::AbstractVector{<:Real}: times vector in ms\np0=nothing: starting values for fit, if empty p0=[maximum(ima),30,maximum(ima)*0.1]\n\nKeywords\n\nremovePoint::Bool=true: remove the first point before fitting\nL::Int=1: Number of coil elements\nmask::\n\nReturns\n\nfit_params : parameter maps last dimension stores the following maps (M₀ , T₂ , σ)\n\nBibliography\n\nCárdenas-Blanco A, Tejos C, Irarrazaval P, Cameron I. Noise in magnitude magnetic\n\nresonance images. Concepts Magn Reson Part A [Internet]. 2008 Nov;32A(6):409?16. Available from: http://doi.wiley.com/10.1002/cmr.a.20124\n\nFeng Y, He T, Gatehouse PD, Li X, Harith Alam M, Pennell DJ, et al. Improved MRI R 2 *\n\nrelaxometry of iron-loaded liver with noise correction. Magn Reson Med [Internet]. 2013 Dec;70(6):1765?74. Available from: http://doi.wiley.com/10.1002/mrm.24607\n\n\n\n\n\n","category":"function"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"The keyword removePoint can be used to delete the first point in the TE vector as well as the first temporal volume in order to reduce the sensitivity of the fit to the stimulated echo.","category":"page"},{"location":"fit_T2/#EPG-T_2-fitting-noise-(WIP)","page":"T₂ mapping","title":"EPG T_2 fitting + noise (WIP)","text":"","category":"section"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"Another possibility is to fit the equation with an EPG model that, in addition to M_0/T_2/sigma, also fit the B_1 field.","category":"page"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"With the current implementation, the fit is not robust enough  and also takes too long to use on a volumic volume.","category":"page"},{"location":"fit_T2/","page":"T₂ mapping","title":"T₂ mapping","text":"T2Fit_epg_noise","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Subspace_MESE]","category":"page"},{"location":"api/#Subspace_MESE.MESE_EPG-Union{Tuple{Ty}, Tuple{Ty, Ty, Ty, Ty, Int64, Ty, Int64}} where Ty<:AbstractFloat","page":"API","title":"Subspace_MESE.MESE_EPG","text":"MESE_EPG(T2::Ty,T1::Ty,TE::Ty,TR::Ty,ETL::Int,delta::Ty,dummy::Int) where Ty <: AbstractFloat\n\nGenerate the signal evolution of a Multi-Echo Spin-Echo sequence with an Extended Phase Graph model.\n\nInput :\n\n- `T2` : Transverse relaxation\n- `T1` : Longitudinal relaxation\n- `TE` : Echo Time\n- `TR` : Repetition time\n- `ETL` : Echo Train Length\n\nOutput :\n\n- Amplitude of each echoes\n\n\n\n\n\n","category":"method"},{"location":"api/#Subspace_MESE.MESE_basis_EPG","page":"API","title":"Subspace_MESE.MESE_basis_EPG","text":"MESE_basis_EPG(NUM_BASIS::Int,TE,ETL::Int,T2_vec::Union{AbstractVector,AbstractFloat},B1_vec::Union{AbstractVector,AbstractFloat} = 1.0,T1_vec::Union{AbstractVector,AbstractFloat}=1000.0;TR = 1000.0,dummy::Int = 3)\n\nGenerate a temporal basis for a Multi-Echo Spin-Echo sequence with an Extended Phase Graph model for various value of T2/B1/T1\n\nstored as a vector in T2_vec/B1_vec/T1_vec.\n\nInput :\n\n- `NUM_BASIS::Int : Number of temporal basis to extract\n- `TE::AbstractFloat` : Cartesian acquisition with a fully-sampled center.\n- `ETL::Int` : Echo Train Length\n- `T2_vec::Union{AbstractVector,AbstractFloat}` : Vector of T₂ values used to generate the signal dictionnary \n- `B1_vec::Union{AbstractVector,AbstractFloat}` : Vector of B₁ values used to generate the signal dictionnary \n- `T1_vec::Union{AbstractVector,AbstractFloat}` : Vector of T₁ values used to generate the signal dictionnary\n\nKeyword :\n\n- `TR` : Repetition time\n- `dummy` : Number of dummy scan before extracting the signal value\n\nOutput :\n\n- `basis` : Matrix of size (ETL,NUM_BASIS)\n- `epg_dict` : Dictionnary of signal used to generate the basis\n\nExample :\n\nB1_vec = 0.8:0.01:1.0\nT2_vec = 1.0:1.0:2000.0\nT1_vec = 1000.0 #can also be a float\nTE = 7.0\nTR = 1000.0\ndummy=3\nETL = 50\nNUM_BASIS = 6\n\nbasis_epg, epg_dict =MESE_basis_EPG(NUM_BASIS,TE,ETL,T2_vec,B1_vec,T1_vec;TR=TR,dummy=dummy)\n\n\n\n\n\n","category":"function"},{"location":"api/#Subspace_MESE.MESE_basis_exp-Tuple{Int64, AbstractFloat, Int64, AbstractVector}","page":"API","title":"Subspace_MESE.MESE_basis_exp","text":"    MESE_basis_exp(NUM_BASIS::Int,TE::AbstractFloat,ETL::Int, T2_vec::AbstractVector;removeFirstPoint::Bool=false)\n\nGenerate a temporal basis for a Multi-Echo Spin-Echo sequence with an exponential model.for various value of T2  stored as a vector in T2_vec. The first point of the echo train can be removed from the dictionnary  with the keyword removeFirstPoint to minimize the effect of stimulated echoes. \n\nInput :\n\n- `NUM_BASIS::Int : Number of temporal basis to extract\n- `TE::AbstractFloat` : Cartesian acquisition with a fully-sampled center.\n- `ETL::Int` : Echo Train Length\n- `T2_vec::AbstractVector` : Vector of T₂ values used to generate the signal dictionnary\n\nKeyword :\n\n- `removeFirstPoint::Bool=False` : Remove the first point of the dictionnary before the svd\n\nOutput :\n\n- `basis` : Matrix of size (ETL,NUM_BASIS)\n- `exp_dict` : Dictionnary of signal used to generate the basis\n\nExample :\n\nT2_vec = 1.0:1.0:2000.0\nTE = 7.0\nETL = 50\nNUM_BASIS = 6\n\nbasis_exp,exp_dict = MESE_basis_exp(NUM_BASIS,TE,ETL,T2_vec)\n\n\n\n\n\n","category":"method"},{"location":"api/#Subspace_MESE.RawAcquisitionData_MESE-Tuple{MRIFiles.BrukerFile}","page":"API","title":"Subspace_MESE.RawAcquisitionData_MESE","text":"RawAcquisitionData_MESE(b::BrukerFile)\n\nConvert a Bruker dataset acquired with the aMESECS sequence into a  RawAcquisitionData object compatible with the MRIReco functions.\n\nInput :      - b::BrukerFile\n\nOutput :     - raw::RawAcquisitionData\n\n\n\n\n\n","category":"method"},{"location":"api/#Subspace_MESE.T2Fit_epg_noise-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, AbstractVector{T}}, Tuple{Array{T, N}, AbstractVector{T}, Any}, Tuple{Array{T, N}, AbstractVector{T}, Any, Any}} where {T<:Real, N}","page":"API","title":"Subspace_MESE.T2Fit_epg_noise","text":"T2Fit_epg_noise(ima::Array{T,N}, t::AbstractVector{T},T1=1000.0,TE=7.0; EPGthresh = 1e-5,p0=nothing,mask = nothing) where {T<:Real,N}\n\nWIP\n\n\n\n\n\n","category":"method"},{"location":"api/#Subspace_MESE.T2Fit_exp_noise-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, AbstractVector{T}}} where {T<:Real, N}","page":"API","title":"Subspace_MESE.T2Fit_exp_noise","text":"    T2Fit_exp_noise(ima::Array{T,N}, t::AbstractVector{T}; removePoint::Bool=true, L::Int=1, mask = nothing) where {T<:Real,N}\n\nFit the relaxation parameters T2 with the equation : S(t) = sqrt(M_0 exp(-fractT2))^2 + 2 L sigma_g^2 where L est le nombre de canaux, et sigma_g le bruit gaussien sur les image\n\nArguments\n\nima::Array{T,N}: multi-dimensionnal images. Last dimension stores the temporal dimension\nt::AbstractVector{<:Real}: times vector in ms\np0=nothing: starting values for fit, if empty p0=[maximum(ima),30,maximum(ima)*0.1]\n\nKeywords\n\nremovePoint::Bool=true: remove the first point before fitting\nL::Int=1: Number of coil elements\nmask::\n\nReturns\n\nfit_params : parameter maps last dimension stores the following maps (M₀ , T₂ , σ)\n\nBibliography\n\nCárdenas-Blanco A, Tejos C, Irarrazaval P, Cameron I. Noise in magnitude magnetic\n\nresonance images. Concepts Magn Reson Part A [Internet]. 2008 Nov;32A(6):409?16. Available from: http://doi.wiley.com/10.1002/cmr.a.20124\n\nFeng Y, He T, Gatehouse PD, Li X, Harith Alam M, Pennell DJ, et al. Improved MRI R 2 *\n\nrelaxometry of iron-loaded liver with noise correction. Magn Reson Med [Internet]. 2013 Dec;70(6):1765?74. Available from: http://doi.wiley.com/10.1002/mrm.24607\n\n\n\n\n\n","category":"method"},{"location":"api/#Subspace_MESE.basis_calibration-Union{Tuple{D}, Tuple{T}, Tuple{Int64, MRIBase.AcquisitionData{T, D}, Tuple{Vararg{Int64, D}}}} where {T, D}","page":"API","title":"Subspace_MESE.basis_calibration","text":"basis_calibration(NUM_BASIS::Int,acq::AcquisitionData{T,D},crop_size::NTuple{D,Int}) where {T,D}\n\nk_bart = kDataCart(acq);  \n\nExtract a temporal basis from a low-resolution images reconstructed using a fully sampled  area at the center of the k-space with a size crop_size. \n\nInput :\n\n- `NUM_BASIS::Int : Number of temporal basis to extract\n- `acq::AcquisitionData` : Cartesian acquisition with a fully-sampled center.\n- `crop_size::NTuple{D,Int})` : size of the  central part of k-space used\n\nOutput :\n\n- `basis` : Matrix of size (ETL,NUM_BASIS)\n- `calib_dict` : Dictionnary of signal used to generate the basis\n\nExample :\n\nb = BrukerFile(\"path/to/dataset\")\n\nraw = RawAcquisitionData_MESE(b)\nacq = AcquisitionData(raw,OffsetBruker = true);\n\nbasis, calib_dict = MESE_basis_calibration(acq,(15,15,15),6)\n\n\n\n\n\n","category":"method"},{"location":"api/#Subspace_MESE.subspace_bart_reconstruction-Tuple{MRIBase.AcquisitionData, Dict{Symbol, Any}, AbstractString}","page":"API","title":"Subspace_MESE.subspace_bart_reconstruction","text":"subspace_bart_reconstruction(acq::AcquisitionData,params::Dict{Symbol,Any},bart_path::AbstractString)\n\nReconstruction of the accelerated MESE sequence with BART.\n\nInput :\n\n- `acq::AcquisitionData` : Cartesian acquisition with a fully-sampled center.\n- `params::Dict{Symbol,Any}` : size of the  central part of k-space used\n- `bart_path::AbstractString` : path to the BART executable library\n\nOutput :\n\n- `basis` : Matrix of size (ETL,NUM_BASIS)\n- `calib_dict` : Dictionnary of signal used to generate the basis\n\nExample :\n\nb = BrukerFile(\"path/to/dataset\")\n\nraw = RawAcquisitionData_MESE(b)\nacq = AcquisitionData(raw,OffsetBruker = true);\n\nbasis, calib_dict = MESE_basis_calibration(acq,(15,15,15),6)\n\n\n\n\n\n","category":"method"},{"location":"building_basis/#Building-temporal-basis","page":"Temporal Basis","title":"Building temporal basis","text":"","category":"section"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"This package implement 3 differents temporal basis :","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"Exponential basis\nExtended Phase Graph (EPG) basis\nCalibration basis","category":"page"},{"location":"building_basis/#How-to-build-a-basis","page":"Temporal Basis","title":"How to build a basis","text":"","category":"section"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"The 3 methods are based on the same concept :","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"Generate a dictionnary with the evolution of the signal at each echo time signal_dict","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"Apply with the Singular Value Decomposition on it","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"svd_obj = svd(signal_dict)","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"and then crop to the desired number of basis","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"basis = ComplexF32.(svd_obj.V)[:, 1:NUM_BASIS]","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"This concept can be applied to create your own basis for example directly from echo images.","category":"page"},{"location":"building_basis/#Difference-between-the-3-methods","page":"Temporal Basis","title":"Difference between the 3 methods","text":"","category":"section"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"Exponential and EPG basis build a dictionnary withthe signal evolution of the Multi-Echo Spin-Echo sequence for various T_2 (or B_1 for the EPG case).","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"The Calibration basis reconstructs low-resolution images at each Echo Time points with the calibration fully sampled area.","category":"page"},{"location":"building_basis/#Exponential-basis","page":"Temporal Basis","title":"Exponential basis","text":"","category":"section"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"MESE_basis_exp","category":"page"},{"location":"building_basis/#Subspace_MESE.MESE_basis_exp","page":"Temporal Basis","title":"Subspace_MESE.MESE_basis_exp","text":"    MESE_basis_exp(NUM_BASIS::Int,TE::AbstractFloat,ETL::Int, T2_vec::AbstractVector;removeFirstPoint::Bool=false)\n\nGenerate a temporal basis for a Multi-Echo Spin-Echo sequence with an exponential model.for various value of T2  stored as a vector in T2_vec. The first point of the echo train can be removed from the dictionnary  with the keyword removeFirstPoint to minimize the effect of stimulated echoes. \n\nInput :\n\n- `NUM_BASIS::Int : Number of temporal basis to extract\n- `TE::AbstractFloat` : Cartesian acquisition with a fully-sampled center.\n- `ETL::Int` : Echo Train Length\n- `T2_vec::AbstractVector` : Vector of T₂ values used to generate the signal dictionnary\n\nKeyword :\n\n- `removeFirstPoint::Bool=False` : Remove the first point of the dictionnary before the svd\n\nOutput :\n\n- `basis` : Matrix of size (ETL,NUM_BASIS)\n- `exp_dict` : Dictionnary of signal used to generate the basis\n\nExample :\n\nT2_vec = 1.0:1.0:2000.0\nTE = 7.0\nETL = 50\nNUM_BASIS = 6\n\nbasis_exp,exp_dict = MESE_basis_exp(NUM_BASIS,TE,ETL,T2_vec)\n\n\n\n\n\n","category":"function"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"In the publication, the basis is extracted from a dictionnary generated with a range of T_2 from 1 ms to 2000 ms with a step of 1 ms.","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"Other approachs can be used :","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"a logarithmic repartition of T_2 \nextracting from a fully acquisition the distribution of T_2 and then generates from that distribution the dictionnary (Tamir et al, MRM,2017)","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"Let's take a look at the first 6 basis from a linear repartition","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"using Subspace_MESE\n\nT2_vec = 1.0:1.0:2000.0\nTE = 7.0\nETL = 50\nNUM_BASIS = 6\n\nbasis_exp,_=MESE_basis_exp(NUM_BASIS,TE,ETL,T2_vec)\n\nusing CairoMakie\ncolor = Makie.wong_colors()\nf = Figure()\nax=Axis(f[1,1])\nfor b in 1:6\n    lines!(ax,abs.(basis_exp[:,b]),color=color[b],label = \"Basis n°$b\")\nend\nhidedecorations!(ax)\naxislegend(ax)\nf","category":"page"},{"location":"building_basis/#EPG-basis","page":"Temporal Basis","title":"EPG basis","text":"","category":"section"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"MESE_basis_EPG","category":"page"},{"location":"building_basis/#Subspace_MESE.MESE_basis_EPG","page":"Temporal Basis","title":"Subspace_MESE.MESE_basis_EPG","text":"MESE_basis_EPG(NUM_BASIS::Int,TE,ETL::Int,T2_vec::Union{AbstractVector,AbstractFloat},B1_vec::Union{AbstractVector,AbstractFloat} = 1.0,T1_vec::Union{AbstractVector,AbstractFloat}=1000.0;TR = 1000.0,dummy::Int = 3)\n\nGenerate a temporal basis for a Multi-Echo Spin-Echo sequence with an Extended Phase Graph model for various value of T2/B1/T1\n\nstored as a vector in T2_vec/B1_vec/T1_vec.\n\nInput :\n\n- `NUM_BASIS::Int : Number of temporal basis to extract\n- `TE::AbstractFloat` : Cartesian acquisition with a fully-sampled center.\n- `ETL::Int` : Echo Train Length\n- `T2_vec::Union{AbstractVector,AbstractFloat}` : Vector of T₂ values used to generate the signal dictionnary \n- `B1_vec::Union{AbstractVector,AbstractFloat}` : Vector of B₁ values used to generate the signal dictionnary \n- `T1_vec::Union{AbstractVector,AbstractFloat}` : Vector of T₁ values used to generate the signal dictionnary\n\nKeyword :\n\n- `TR` : Repetition time\n- `dummy` : Number of dummy scan before extracting the signal value\n\nOutput :\n\n- `basis` : Matrix of size (ETL,NUM_BASIS)\n- `epg_dict` : Dictionnary of signal used to generate the basis\n\nExample :\n\nB1_vec = 0.8:0.01:1.0\nT2_vec = 1.0:1.0:2000.0\nT1_vec = 1000.0 #can also be a float\nTE = 7.0\nTR = 1000.0\ndummy=3\nETL = 50\nNUM_BASIS = 6\n\nbasis_epg, epg_dict =MESE_basis_EPG(NUM_BASIS,TE,ETL,T2_vec,B1_vec,T1_vec;TR=TR,dummy=dummy)\n\n\n\n\n\n","category":"function"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"In order to generate the EPG basis, more parameters needs to be defined. Especially the range of B_1 to be expected in the acquisition which might be larger for surfacic transmit coil than in our case with a pretty homogeneous B_1^+ field with the volumic coil.","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"To note, B1vec, T2vec, T1vec can also be float value (not vector). In the publication, the T1vec was fixed to 1000 ms.","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"using Subspace_MESE\nB1_vec = 0.8:0.01:1.0\nT2_vec = 1.0:1.0:2000.0\nT1_vec = 1000.0 #can also be a float\nTE = 7.0\nTR = 1000.0\ndummy=3\nETL = 50\nNUM_BASIS = 6\n\nbasis_epg,_=MESE_basis_EPG(NUM_BASIS,TE,ETL,T2_vec,B1_vec,T1_vec;TR=TR,dummy=dummy)\n\nusing CairoMakie\ncolor = Makie.wong_colors()\nf = Figure()\nax=Axis(f[1,1])\nfor b in 1:6\n    lines!(ax,abs.(basis_epg[:,b]),color=color[b],label = \"Basis n°$b\")\nend\nhidedecorations!(ax)\naxislegend(ax)\nf","category":"page"},{"location":"building_basis/#Calibration-basis","page":"Temporal Basis","title":"Calibration basis","text":"","category":"section"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"basis_calibration","category":"page"},{"location":"building_basis/#Subspace_MESE.basis_calibration","page":"Temporal Basis","title":"Subspace_MESE.basis_calibration","text":"basis_calibration(NUM_BASIS::Int,acq::AcquisitionData{T,D},crop_size::NTuple{D,Int}) where {T,D}\n\nk_bart = kDataCart(acq);  \n\nExtract a temporal basis from a low-resolution images reconstructed using a fully sampled  area at the center of the k-space with a size crop_size. \n\nInput :\n\n- `NUM_BASIS::Int : Number of temporal basis to extract\n- `acq::AcquisitionData` : Cartesian acquisition with a fully-sampled center.\n- `crop_size::NTuple{D,Int})` : size of the  central part of k-space used\n\nOutput :\n\n- `basis` : Matrix of size (ETL,NUM_BASIS)\n- `calib_dict` : Dictionnary of signal used to generate the basis\n\nExample :\n\nb = BrukerFile(\"path/to/dataset\")\n\nraw = RawAcquisitionData_MESE(b)\nacq = AcquisitionData(raw,OffsetBruker = true);\n\nbasis, calib_dict = MESE_basis_calibration(acq,(15,15,15),6)\n\n\n\n\n\n","category":"function"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"The calibration basis reconstructs low-resolution images from a center area. ","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"You can generate the basis from the acquired accelerated acquisition with a crop_size equal to the size of the calibration data.","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"But you can also generate the basis from a different fully acquisition.","category":"page"},{"location":"building_basis/","page":"Temporal Basis","title":"Temporal Basis","text":"b = BrukerFile(\"path/to/dataset\")\n\nraw = RawAcquisitionData_MESE(b)\nacq = AcquisitionData(raw,OffsetBruker = true);\n\nbasis,_ = MESE_basis_calibration(acq,(15,15,15),6)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Subspace_MESE","category":"page"},{"location":"#Subspace_MESE","page":"Home","title":"Subspace_MESE","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the Subspace_MESE package, which implement the necessary functions to convert and reconstruct an accelerated 3D Multi-Echo Spin-Echo sequence with a subspace reconstruction in order to generate T2 maps.","category":"page"},{"location":"#Bruker-Acquisition","page":"Home","title":"Bruker Acquisition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is compatible with the sequence : a_MESE_CS which is available as a binary file in the folder : MRI/PV6.0.1/","category":"page"},{"location":"","page":"Home","title":"Home","text":"The sequence is only available for the version PV6.0.1, implementation under PV360.6.5 is in progress. The protocol used for an acceleration factor of CS=6/8/10 is also available at the same adress.","category":"page"},{"location":"#Reconstruction-Pipeline","page":"Home","title":"Reconstruction Pipeline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The reconstruction pipeline has 4 steps :","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convertion of the Bruker rawdataset to a MRIReco compatible format (/src/bruker_sequence.jl)\nGeneration of a temporal basis (/src/build_basis.jl)\nReconstruction which is presented either as a script or a standard implementation\nT2 fitting (/src/fit_T2_MESE.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Reconstruction Pipeline)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Those steps are described in their dedicated section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A complete script is available at this link.","category":"page"},{"location":"reconstruction_subspace/#Compressed-sensing-reconstruction-with-a-subspace-constrained","page":"Subspace Reconstruction","title":"Compressed sensing reconstruction with a subspace constrained","text":"","category":"section"},{"location":"reconstruction_subspace/#Background","page":"Subspace Reconstruction","title":"Background","text":"","category":"section"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"The main idea is to solve the following problem :","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"min_x frac12y - E Phi_K alpha^2_2 + lambdaW(alpha)_1","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"where y is the k-space data, E is the encoding operator regrouping the FFT operator and the coil sensitvity operator. Phi_K is the orthonormal temporal basis cropped to the first K temporal basis, alpha is the temporal basis coefficient maps and W correspond to the Wavelet Operator which is applied on alpha.","category":"page"},{"location":"reconstruction_subspace/#Julia-implementation","page":"Subspace Reconstruction","title":"Julia implementation","text":"","category":"section"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"The subspace reconstruction was implemented as part of MRIReco.jl package. An example can be found here.","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"The reconstruction works on an AcquisitionData object (previously converted from the Bruker raw dataset). Because it is a combined parallel imaging and compressed sensing approach we have to estimate the coil sensitivity map","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"using Subspace_MESE\nusing Subspace_MESE.MRIFiles\nusing Subspace_MESE.MRIReco\nusing Subspace_MESE.MRICoilSensitivities\n\nb=BrukerFile(\"path/to/dataset/\")\nraw = RawAcquisitionData_MESE(b)\nacq = AcquisitionData(raw,OffsetBruker = true);\n\ncoilsens = espirit(acq,eigThresh_2=0.0);\nbasis,dico = basis_calibration(6,acq,(15,15,15))","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"From that point we need to define a Dict (here params) structure to store and pass the MRIReco reconstruction parameters","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"params = Dict{Symbol,Any}()\nparams[:reconSize] = acq.encodingSize\n\n# Subspace \nparams[:reco] = \"multiCoilMultiEchoSubspace\"\nparams[:senseMaps] = coilsens\nparams[:basis] = basis\n\n# Compressed sensing transform\nparams[:regularization] = \"L1\"\nparams[:sparseTrafo] = \"Wavelet\" #sparse trafo\nparams[:λ] = Float32(0.01)\n\n# Algorithm parameters\nparams[:solver] = \"fista\"\nparams[:iterations] = 30\nparams[:normalizeReg] = true","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"params[:reco] = \"multiCoilMultiEchoSubspace\" means it is a subspace reconstruction with parallel imaging and expects the field params[:senseMaps] and params[:basis]","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"The remaining parameters are linked to the algorithm used (wavelet transform + L1 regularization with a FISTA algorithm and 30 iterations)","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"To perform the reconstruction we can now call the function :","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"alpha = reconstruction(acq, params);","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"The results of the reconstruction is not directly the echo images but the subnspace coefficient. We need to apply the basis on it","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"im_TE = abs.(applySubspace(α, basis))","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"warning: Warning\nThe reconstruction part might evolve due to changes in the MRIReco package and its dependencies, particularly RegularizedLeastSquares.jl","category":"page"},{"location":"reconstruction_subspace/#Comparison-with-BART","page":"Subspace Reconstruction","title":"Comparison with BART","text":"","category":"section"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"All the figure from the publication were generated using a reconstruction from BART. For comparison purpose, the reconstruction is also available in this package.","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"You need to compile the BART toolbox : https://mrirecon.github.io/bart/ and write the path to the executable BART library in the subspace_bart_reconstruction which used the wrapper BartIO.jl to send the data back and forth between JULIA and BART.","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"using Subspace_MESE.BartIO\n\nparams = Dict{Symbol,Any}()\nparams[:iterations] = 60\nparams[:λ] = 0.01\nparams[:basis]=basis\n\nim_sub_bart,im_TE_bart = subspace_bart_reconstruction(acq,params,\"/home/CODE/bart/bart\")","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"If you need more control over the reconstruction parameter for BART, take a look at the function (only 20 lines)","category":"page"},{"location":"reconstruction_subspace/","page":"Subspace Reconstruction","title":"Subspace Reconstruction","text":"note: Note\nThe regularization parameters between MRIReco.jl and BART are different and need to be adjusted manually. This can be explained by some low-level differences in the FISTA algorithm / Wavelet transform and also due to scaling of the data prior to the algorithm.","category":"page"},{"location":"convert/#Conversion-from-Bruker-dataset-to-MRIReco.jl-object","page":"Convert data","title":"Conversion from Bruker dataset to MRIReco.jl object","text":"","category":"section"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"After acquisition, you can convert the Bruker dataset to an RawAcquisitionData with the function spectific function RawAcquisitionData_MESE(b::BrukerFile). Conversion is mostly performed with MRIReco/MRIBase and MRIFiles functions. ","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"We need to import them first :","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"using Subspace_MESE\nusing Subspace_MESE.MRIFiles\nusing Subspace_MESE.MRIReco\n\nb=BrukerFile(\"path/to/dataset/20230317_085834_AT_MSME_CS_44_1_1/10\")\nraw = RawAcquisitionData_MESE(b)","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"The RawAcquisitionData object is an implementation of the MRD format. after that point the remaining function are purely in the MRIReco.jl package. ","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"In order to perform the reconstruction we need to convert the raw object to an AcquisitionData object with the following command :","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"acq = AcquisitionData(raw,OffsetBruker = true);","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"The keyword OffsetBruker is equal to true in order to correct the offset of the FOV along the phase and partition encoding (specific to Bruker).","category":"page"},{"location":"convert/#Direct-reconstruction","page":"Convert data","title":"Direct reconstruction","text":"","category":"section"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"From that point the user should take a look at the MRIReco.jl documentation in order to perfom the reconstruction. ","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"A direct reconstruction leading to undersampled artifacts can be implemented like :","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"params = Dict{Symbol,Any}()\nparams[:reconSize] = acq.encodingSize\nparams[:reco] = \"direct\"\n\nim_u = reconstruction(acq, params);","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"We can combine the different coil elements with a sum of squares :","category":"page"},{"location":"convert/","page":"Convert data","title":"Convert data","text":"using Subspace_MESE.MRICoilSensitivities\nim_u_sos = mergeChannels(im_u)","category":"page"}]
}
